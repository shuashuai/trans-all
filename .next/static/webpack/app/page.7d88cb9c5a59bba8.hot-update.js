"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/stores/translation-store.ts":
/*!*****************************************!*\
  !*** ./src/stores/translation-store.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTranslationConfig: () => (/* binding */ useTranslationConfig),\n/* harmony export */   useTranslationProgress: () => (/* binding */ useTranslationProgress),\n/* harmony export */   useTranslationResult: () => (/* binding */ useTranslationResult),\n/* harmony export */   useTranslationStatus: () => (/* binding */ useTranslationStatus),\n/* harmony export */   useTranslationStore: () => (/* binding */ useTranslationStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/.pnpm/zustand@5.0.8_@types+react@19.1.11_react@19.1.1/node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var _lib_ai_translation_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/ai/translation-service */ \"(app-pages-browser)/./src/lib/ai/translation-service.ts\");\n\n\nconst useTranslationStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set, get)=>({\n        // Initial state\n        service: new _lib_ai_translation_service__WEBPACK_IMPORTED_MODULE_0__.TranslationService(),\n        config: null,\n        isConfigured: false,\n        isTranslating: false,\n        isPaused: false,\n        progress: null,\n        result: null,\n        abortController: null,\n        showSettings: false,\n        // Configure the translation service\n        configure: async (config)=>{\n            const { service } = get();\n            try {\n                // Validate API key first\n                const isValid = await _lib_ai_translation_service__WEBPACK_IMPORTED_MODULE_0__.TranslationService.validateApiKey(config.provider, config.apiKey, config.baseUrl);\n                if (!isValid) {\n                    throw new Error('Invalid API key');\n                }\n                service.initialize(config);\n                set({\n                    config,\n                    isConfigured: true,\n                    showSettings: false\n                });\n            } catch (error) {\n                console.error('Failed to configure translation service:', error);\n                throw error;\n            }\n        },\n        // Start translation\n        startTranslation: async (originalData, structure)=>{\n            const { service, config } = get();\n            if (!config || !service.isInitialized()) {\n                throw new Error('Translation service not configured');\n            }\n            const abortController = new AbortController();\n            set({\n                isTranslating: true,\n                isPaused: false,\n                progress: null,\n                result: null,\n                abortController\n            });\n            try {\n                const result = await service.translateYAMLStructure(originalData, structure, get().handleProgress, abortController.signal);\n                set({\n                    result,\n                    isTranslating: false,\n                    abortController: null\n                });\n            } catch (error) {\n                console.error('Translation failed:', error);\n                set({\n                    isTranslating: false,\n                    abortController: null,\n                    progress: {\n                        currentItem: 0,\n                        totalItems: structure.length,\n                        currentKey: '',\n                        currentValue: '',\n                        progress: 0,\n                        status: 'error',\n                        error: error instanceof Error ? error.message : 'Translation failed'\n                    }\n                });\n            }\n        },\n        // Pause translation (not yet implemented in service)\n        pauseTranslation: ()=>{\n            set({\n                isPaused: true\n            });\n        },\n        // Resume translation (not yet implemented in service)\n        resumeTranslation: ()=>{\n            set({\n                isPaused: false\n            });\n        },\n        // Stop translation\n        stopTranslation: ()=>{\n            const { abortController } = get();\n            if (abortController) {\n                abortController.abort();\n            }\n            set({\n                isTranslating: false,\n                isPaused: false,\n                abortController: null,\n                progress: {\n                    currentItem: 0,\n                    totalItems: 0,\n                    currentKey: '',\n                    currentValue: '',\n                    progress: 0,\n                    status: 'error',\n                    error: 'Translation cancelled by user'\n                }\n            });\n        },\n        // Reset everything\n        reset: ()=>{\n            const { service, abortController } = get();\n            if (abortController) {\n                abortController.abort();\n            }\n            service.reset();\n            set({\n                config: null,\n                isConfigured: false,\n                isTranslating: false,\n                isPaused: false,\n                progress: null,\n                result: null,\n                abortController: null,\n                showSettings: false\n            });\n        },\n        // Toggle settings modal\n        toggleSettings: ()=>{\n            set((state)=>({\n                    showSettings: !state.showSettings\n                }));\n        },\n        // Update configuration\n        updateConfig: (updates)=>{\n            const { config } = get();\n            if (config) {\n                const newConfig = {\n                    ...config,\n                    ...updates\n                };\n                set({\n                    config: newConfig\n                });\n            }\n        },\n        // Handle progress updates\n        handleProgress: (progress)=>{\n            set({\n                progress\n            });\n        }\n    }));\n// Stable selectors for easier component usage\nconst selectConfig = (state)=>state.config;\nconst selectProgress = (state)=>state.progress;\nconst selectResult = (state)=>state.result;\nconst selectStatus = (state)=>({\n        isTranslating: state.isTranslating,\n        isPaused: state.isPaused,\n        isConfigured: state.isConfigured\n    });\nconst useTranslationConfig = ()=>useTranslationStore(selectConfig);\nconst useTranslationProgress = ()=>useTranslationStore(selectProgress);\nconst useTranslationResult = ()=>useTranslationStore(selectResult);\nconst useTranslationStatus = ()=>useTranslationStore(selectStatus);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZXMvdHJhbnNsYXRpb24tc3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFnQztBQUN1RTtBQXNDaEcsTUFBTUUsc0JBQXNCRiwrQ0FBTUEsQ0FBbUIsQ0FBQ0csS0FBS0MsTUFBUztRQUN6RSxnQkFBZ0I7UUFDaEJDLFNBQVMsSUFBSUosMkVBQWtCQTtRQUMvQkssUUFBUTtRQUNSQyxjQUFjO1FBQ2RDLGVBQWU7UUFDZkMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsaUJBQWlCO1FBQ2pCQyxjQUFjO1FBRWQsb0NBQW9DO1FBQ3BDQyxXQUFXLE9BQU9SO1lBQ2hCLE1BQU0sRUFBRUQsT0FBTyxFQUFFLEdBQUdEO1lBRXBCLElBQUk7Z0JBQ0YseUJBQXlCO2dCQUN6QixNQUFNVyxVQUFVLE1BQU1kLDJFQUFrQkEsQ0FBQ2UsY0FBYyxDQUNyRFYsT0FBT1csUUFBUSxFQUNmWCxPQUFPWSxNQUFNLEVBQ2JaLE9BQU9hLE9BQU87Z0JBR2hCLElBQUksQ0FBQ0osU0FBUztvQkFDWixNQUFNLElBQUlLLE1BQU07Z0JBQ2xCO2dCQUVBZixRQUFRZ0IsVUFBVSxDQUFDZjtnQkFFbkJILElBQUk7b0JBQ0ZHO29CQUNBQyxjQUFjO29CQUNkTSxjQUFjO2dCQUNoQjtZQUNGLEVBQUUsT0FBT1MsT0FBTztnQkFDZEMsUUFBUUQsS0FBSyxDQUFDLDRDQUE0Q0E7Z0JBQzFELE1BQU1BO1lBQ1I7UUFDRjtRQUVBLG9CQUFvQjtRQUNwQkUsa0JBQWtCLE9BQU9DLGNBQW1CQztZQUMxQyxNQUFNLEVBQUVyQixPQUFPLEVBQUVDLE1BQU0sRUFBRSxHQUFHRjtZQUU1QixJQUFJLENBQUNFLFVBQVUsQ0FBQ0QsUUFBUXNCLGFBQWEsSUFBSTtnQkFDdkMsTUFBTSxJQUFJUCxNQUFNO1lBQ2xCO1lBRUEsTUFBTVIsa0JBQWtCLElBQUlnQjtZQUU1QnpCLElBQUk7Z0JBQ0ZLLGVBQWU7Z0JBQ2ZDLFVBQVU7Z0JB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eEUsTUFBTUssdUJBQXVCLElBQU1yRCxvQkFBb0JpRCxjQUFhO0FBQ3BFLE1BQU1LLHVCQUF1QixJQUFNdEQsb0JBQW9Ca0QsY0FBYSIsInNvdXJjZXMiOlsiL1VzZXJzL3NodWFpL2dpdGh1Yi90cmFucy15YW1sL3NyYy9zdG9yZXMvdHJhbnNsYXRpb24tc3RvcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCdcbmltcG9ydCB7IFRyYW5zbGF0aW9uU2VydmljZSwgVHJhbnNsYXRpb25TZXNzaW9uQ29uZmlnLCBBSVByb3ZpZGVyIH0gZnJvbSAnQC9saWIvYWkvdHJhbnNsYXRpb24tc2VydmljZSdcbmltcG9ydCB7IFRyYW5zbGF0aW9uUHJvZ3Jlc3MsIFN0cmVhbWluZ1RyYW5zbGF0aW9uUmVzdWx0IH0gZnJvbSAnQC9saWIvYWkvYmFzZS10cmFuc2xhdG9yJ1xuaW1wb3J0IHsgWUFNTFN0cnVjdHVyZUl0ZW0gfSBmcm9tICdAL2xpYi95YW1sLXByb2Nlc3NvcidcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xhdGlvblN0YXRlIHtcbiAgLy8gU2VydmljZSBpbnN0YW5jZVxuICBzZXJ2aWNlOiBUcmFuc2xhdGlvblNlcnZpY2VcbiAgXG4gIC8vIENvbmZpZ3VyYXRpb25cbiAgY29uZmlnOiBUcmFuc2xhdGlvblNlc3Npb25Db25maWcgfCBudWxsXG4gIGlzQ29uZmlndXJlZDogYm9vbGVhblxuICBcbiAgLy8gVHJhbnNsYXRpb24gc3RhdGVcbiAgaXNUcmFuc2xhdGluZzogYm9vbGVhblxuICBpc1BhdXNlZDogYm9vbGVhblxuICBwcm9ncmVzczogVHJhbnNsYXRpb25Qcm9ncmVzcyB8IG51bGxcbiAgcmVzdWx0OiBTdHJlYW1pbmdUcmFuc2xhdGlvblJlc3VsdCB8IG51bGxcbiAgYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIgfCBudWxsXG4gIFxuICAvLyBVSSBzdGF0ZVxuICBzaG93U2V0dGluZ3M6IGJvb2xlYW5cbiAgXG4gIC8vIEFjdGlvbnNcbiAgY29uZmlndXJlOiAoY29uZmlnOiBUcmFuc2xhdGlvblNlc3Npb25Db25maWcpID0+IFByb21pc2U8dm9pZD5cbiAgc3RhcnRUcmFuc2xhdGlvbjogKG9yaWdpbmFsRGF0YTogYW55LCBzdHJ1Y3R1cmU6IFlBTUxTdHJ1Y3R1cmVJdGVtW10pID0+IFByb21pc2U8dm9pZD5cbiAgcGF1c2VUcmFuc2xhdGlvbjogKCkgPT4gdm9pZFxuICByZXN1bWVUcmFuc2xhdGlvbjogKCkgPT4gdm9pZFxuICBzdG9wVHJhbnNsYXRpb246ICgpID0+IHZvaWRcbiAgcmVzZXQ6ICgpID0+IHZvaWRcbiAgXG4gIC8vIFNldHRpbmdzIGFjdGlvbnNcbiAgdG9nZ2xlU2V0dGluZ3M6ICgpID0+IHZvaWRcbiAgdXBkYXRlQ29uZmlnOiAodXBkYXRlczogUGFydGlhbDxUcmFuc2xhdGlvblNlc3Npb25Db25maWc+KSA9PiB2b2lkXG4gIFxuICAvLyBQcm9ncmVzcyBjYWxsYmFja1xuICBoYW5kbGVQcm9ncmVzczogKHByb2dyZXNzOiBUcmFuc2xhdGlvblByb2dyZXNzKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBjb25zdCB1c2VUcmFuc2xhdGlvblN0b3JlID0gY3JlYXRlPFRyYW5zbGF0aW9uU3RhdGU+KChzZXQsIGdldCkgPT4gKHtcbiAgLy8gSW5pdGlhbCBzdGF0ZVxuICBzZXJ2aWNlOiBuZXcgVHJhbnNsYXRpb25TZXJ2aWNlKCksXG4gIGNvbmZpZzogbnVsbCxcbiAgaXNDb25maWd1cmVkOiBmYWxzZSxcbiAgaXNUcmFuc2xhdGluZzogZmFsc2UsXG4gIGlzUGF1c2VkOiBmYWxzZSxcbiAgcHJvZ3Jlc3M6IG51bGwsXG4gIHJlc3VsdDogbnVsbCxcbiAgYWJvcnRDb250cm9sbGVyOiBudWxsLFxuICBzaG93U2V0dGluZ3M6IGZhbHNlLFxuXG4gIC8vIENvbmZpZ3VyZSB0aGUgdHJhbnNsYXRpb24gc2VydmljZVxuICBjb25maWd1cmU6IGFzeW5jIChjb25maWc6IFRyYW5zbGF0aW9uU2Vzc2lvbkNvbmZpZykgPT4ge1xuICAgIGNvbnN0IHsgc2VydmljZSB9ID0gZ2V0KClcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gVmFsaWRhdGUgQVBJIGtleSBmaXJzdFxuICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IFRyYW5zbGF0aW9uU2VydmljZS52YWxpZGF0ZUFwaUtleShcbiAgICAgICAgY29uZmlnLnByb3ZpZGVyLFxuICAgICAgICBjb25maWcuYXBpS2V5LFxuICAgICAgICBjb25maWcuYmFzZVVybFxuICAgICAgKVxuICAgICAgXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEFQSSBrZXknKVxuICAgICAgfVxuXG4gICAgICBzZXJ2aWNlLmluaXRpYWxpemUoY29uZmlnKVxuICAgICAgXG4gICAgICBzZXQoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIGlzQ29uZmlndXJlZDogdHJ1ZSxcbiAgICAgICAgc2hvd1NldHRpbmdzOiBmYWxzZVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNvbmZpZ3VyZSB0cmFuc2xhdGlvbiBzZXJ2aWNlOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLy8gU3RhcnQgdHJhbnNsYXRpb25cbiAgc3RhcnRUcmFuc2xhdGlvbjogYXN5bmMgKG9yaWdpbmFsRGF0YTogYW55LCBzdHJ1Y3R1cmU6IFlBTUxTdHJ1Y3R1cmVJdGVtW10pID0+IHtcbiAgICBjb25zdCB7IHNlcnZpY2UsIGNvbmZpZyB9ID0gZ2V0KClcbiAgICBcbiAgICBpZiAoIWNvbmZpZyB8fCAhc2VydmljZS5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNsYXRpb24gc2VydmljZSBub3QgY29uZmlndXJlZCcpXG4gICAgfVxuXG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgXG4gICAgc2V0KHtcbiAgICAgIGlzVHJhbnNsYXRpbmc6IHRydWUsXG4gICAgICBpc1BhdXNlZDogZmFsc2UsXG4gICAgICBwcm9ncmVzczogbnVsbCxcbiAgICAgIHJlc3VsdDogbnVsbCxcbiAgICAgIGFib3J0Q29udHJvbGxlclxuICAgIH0pXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS50cmFuc2xhdGVZQU1MU3RydWN0dXJlKFxuICAgICAgICBvcmlnaW5hbERhdGEsXG4gICAgICAgIHN0cnVjdHVyZSxcbiAgICAgICAgZ2V0KCkuaGFuZGxlUHJvZ3Jlc3MsXG4gICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICAgIClcblxuICAgICAgc2V0KHtcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBpc1RyYW5zbGF0aW5nOiBmYWxzZSxcbiAgICAgICAgYWJvcnRDb250cm9sbGVyOiBudWxsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUcmFuc2xhdGlvbiBmYWlsZWQ6JywgZXJyb3IpXG4gICAgICBcbiAgICAgIHNldCh7XG4gICAgICAgIGlzVHJhbnNsYXRpbmc6IGZhbHNlLFxuICAgICAgICBhYm9ydENvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgY3VycmVudEl0ZW06IDAsXG4gICAgICAgICAgdG90YWxJdGVtczogc3RydWN0dXJlLmxlbmd0aCxcbiAgICAgICAgICBjdXJyZW50S2V5OiAnJyxcbiAgICAgICAgICBjdXJyZW50VmFsdWU6ICcnLFxuICAgICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVHJhbnNsYXRpb24gZmFpbGVkJ1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfSxcblxuICAvLyBQYXVzZSB0cmFuc2xhdGlvbiAobm90IHlldCBpbXBsZW1lbnRlZCBpbiBzZXJ2aWNlKVxuICBwYXVzZVRyYW5zbGF0aW9uOiAoKSA9PiB7XG4gICAgc2V0KHsgaXNQYXVzZWQ6IHRydWUgfSlcbiAgfSxcblxuICAvLyBSZXN1bWUgdHJhbnNsYXRpb24gKG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gc2VydmljZSlcbiAgcmVzdW1lVHJhbnNsYXRpb246ICgpID0+IHtcbiAgICBzZXQoeyBpc1BhdXNlZDogZmFsc2UgfSlcbiAgfSxcblxuICAvLyBTdG9wIHRyYW5zbGF0aW9uXG4gIHN0b3BUcmFuc2xhdGlvbjogKCkgPT4ge1xuICAgIGNvbnN0IHsgYWJvcnRDb250cm9sbGVyIH0gPSBnZXQoKVxuICAgIFxuICAgIGlmIChhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpXG4gICAgfVxuICAgIFxuICAgIHNldCh7XG4gICAgICBpc1RyYW5zbGF0aW5nOiBmYWxzZSxcbiAgICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICAgIGFib3J0Q29udHJvbGxlcjogbnVsbCxcbiAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgIGN1cnJlbnRJdGVtOiAwLFxuICAgICAgICB0b3RhbEl0ZW1zOiAwLFxuICAgICAgICBjdXJyZW50S2V5OiAnJyxcbiAgICAgICAgY3VycmVudFZhbHVlOiAnJyxcbiAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgZXJyb3I6ICdUcmFuc2xhdGlvbiBjYW5jZWxsZWQgYnkgdXNlcidcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuXG4gIC8vIFJlc2V0IGV2ZXJ5dGhpbmdcbiAgcmVzZXQ6ICgpID0+IHtcbiAgICBjb25zdCB7IHNlcnZpY2UsIGFib3J0Q29udHJvbGxlciB9ID0gZ2V0KClcbiAgICBcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICAgIH1cbiAgICBcbiAgICBzZXJ2aWNlLnJlc2V0KClcbiAgICBcbiAgICBzZXQoe1xuICAgICAgY29uZmlnOiBudWxsLFxuICAgICAgaXNDb25maWd1cmVkOiBmYWxzZSxcbiAgICAgIGlzVHJhbnNsYXRpbmc6IGZhbHNlLFxuICAgICAgaXNQYXVzZWQ6IGZhbHNlLFxuICAgICAgcHJvZ3Jlc3M6IG51bGwsXG4gICAgICByZXN1bHQ6IG51bGwsXG4gICAgICBhYm9ydENvbnRyb2xsZXI6IG51bGwsXG4gICAgICBzaG93U2V0dGluZ3M6IGZhbHNlXG4gICAgfSlcbiAgfSxcblxuICAvLyBUb2dnbGUgc2V0dGluZ3MgbW9kYWxcbiAgdG9nZ2xlU2V0dGluZ3M6ICgpID0+IHtcbiAgICBzZXQoc3RhdGUgPT4gKHsgc2hvd1NldHRpbmdzOiAhc3RhdGUuc2hvd1NldHRpbmdzIH0pKVxuICB9LFxuXG4gIC8vIFVwZGF0ZSBjb25maWd1cmF0aW9uXG4gIHVwZGF0ZUNvbmZpZzogKHVwZGF0ZXM6IFBhcnRpYWw8VHJhbnNsYXRpb25TZXNzaW9uQ29uZmlnPikgPT4ge1xuICAgIGNvbnN0IHsgY29uZmlnIH0gPSBnZXQoKVxuICAgIFxuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGNvbnN0IG5ld0NvbmZpZyA9IHsgLi4uY29uZmlnLCAuLi51cGRhdGVzIH1cbiAgICAgIHNldCh7IGNvbmZpZzogbmV3Q29uZmlnIH0pXG4gICAgfVxuICB9LFxuXG4gIC8vIEhhbmRsZSBwcm9ncmVzcyB1cGRhdGVzXG4gIGhhbmRsZVByb2dyZXNzOiAocHJvZ3Jlc3M6IFRyYW5zbGF0aW9uUHJvZ3Jlc3MpID0+IHtcbiAgICBzZXQoeyBwcm9ncmVzcyB9KVxuICB9XG59KSlcblxuLy8gU3RhYmxlIHNlbGVjdG9ycyBmb3IgZWFzaWVyIGNvbXBvbmVudCB1c2FnZVxuY29uc3Qgc2VsZWN0Q29uZmlnID0gKHN0YXRlOiBUcmFuc2xhdGlvblN0YXRlKSA9PiBzdGF0ZS5jb25maWdcbmNvbnN0IHNlbGVjdFByb2dyZXNzID0gKHN0YXRlOiBUcmFuc2xhdGlvblN0YXRlKSA9PiBzdGF0ZS5wcm9ncmVzc1xuY29uc3Qgc2VsZWN0UmVzdWx0ID0gKHN0YXRlOiBUcmFuc2xhdGlvblN0YXRlKSA9PiBzdGF0ZS5yZXN1bHRcbmNvbnN0IHNlbGVjdFN0YXR1cyA9IChzdGF0ZTogVHJhbnNsYXRpb25TdGF0ZSkgPT4gKHtcbiAgaXNUcmFuc2xhdGluZzogc3RhdGUuaXNUcmFuc2xhdGluZyxcbiAgaXNQYXVzZWQ6IHN0YXRlLmlzUGF1c2VkLFxuICBpc0NvbmZpZ3VyZWQ6IHN0YXRlLmlzQ29uZmlndXJlZFxufSlcblxuZXhwb3J0IGNvbnN0IHVzZVRyYW5zbGF0aW9uQ29uZmlnID0gKCkgPT4gdXNlVHJhbnNsYXRpb25TdG9yZShzZWxlY3RDb25maWcpXG5leHBvcnQgY29uc3QgdXNlVHJhbnNsYXRpb25Qcm9ncmVzcyA9ICgpID0+IHVzZVRyYW5zbGF0aW9uU3RvcmUoc2VsZWN0UHJvZ3Jlc3MpXG5leHBvcnQgY29uc3QgdXNlVHJhbnNsYXRpb25SZXN1bHQgPSAoKSA9PiB1c2VUcmFuc2xhdGlvblN0b3JlKHNlbGVjdFJlc3VsdClcbmV4cG9ydCBjb25zdCB1c2VUcmFuc2xhdGlvblN0YXR1cyA9ICgpID0+IHVzZVRyYW5zbGF0aW9uU3RvcmUoc2VsZWN0U3RhdHVzKSJdLCJuYW1lcyI6WyJjcmVhdGUiLCJUcmFuc2xhdGlvblNlcnZpY2UiLCJ1c2VUcmFuc2xhdGlvblN0b3JlIiwic2V0IiwiZ2V0Iiwic2VydmljZSIsImNvbmZpZyIsImlzQ29uZmlndXJlZCIsImlzVHJhbnNsYXRpbmciLCJpc1BhdXNlZCIsInByb2dyZXNzIiwicmVzdWx0IiwiYWJvcnRDb250cm9sbGVyIiwic2hvd1NldHRpbmdzIiwiY29uZmlndXJlIiwiaXNWYWxpZCIsInZhbGlkYXRlQXBpS2V5IiwicHJvdmlkZXIiLCJhcGlLZXkiLCJiYXNlVXJsIiwiRXJyb3IiLCJpbml0aWFsaXplIiwiZXJyb3IiLCJjb25zb2xlIiwic3RhcnRUcmFuc2xhdGlvbiIsIm9yaWdpbmFsRGF0YSIsInN0cnVjdHVyZSIsImlzSW5pdGlhbGl6ZWQiLCJBYm9ydENvbnRyb2xsZXIiLCJ0cmFuc2xhdGVZQU1MU3RydWN0dXJlIiwiaGFuZGxlUHJvZ3Jlc3MiLCJzaWduYWwiLCJjdXJyZW50SXRlbSIsInRvdGFsSXRlbXMiLCJsZW5ndGgiLCJjdXJyZW50S2V5IiwiY3VycmVudFZhbHVlIiwic3RhdHVzIiwibWVzc2FnZSIsInBhdXNlVHJhbnNsYXRpb24iLCJyZXN1bWVUcmFuc2xhdGlvbiIsInN0b3BUcmFuc2xhdGlvbiIsImFib3J0IiwicmVzZXQiLCJ0b2dnbGVTZXR0aW5ncyIsInN0YXRlIiwidXBkYXRlQ29uZmlnIiwidXBkYXRlcyIsIm5ld0NvbmZpZyIsInNlbGVjdENvbmZpZyIsInNlbGVjdFByb2dyZXNzIiwic2VsZWN0UmVzdWx0Iiwic2VsZWN0U3RhdHVzIiwidXNlVHJhbnNsYXRpb25Db25maWciLCJ1c2VUcmFuc2xhdGlvblByb2dyZXNzIiwidXNlVHJhbnNsYXRpb25SZXN1bHQiLCJ1c2VUcmFuc2xhdGlvblN0YXR1cyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/stores/translation-store.ts\n"));

/***/ })

});