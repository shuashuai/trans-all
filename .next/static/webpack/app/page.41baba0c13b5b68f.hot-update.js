"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/ai/translation-service.ts":
/*!*******************************************!*\
  !*** ./src/lib/ai/translation-service.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TranslationService: () => (/* binding */ TranslationService)\n/* harmony export */ });\n/* harmony import */ var _openai_translator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./openai-translator */ \"(app-pages-browser)/./src/lib/ai/openai-translator.ts\");\n/* harmony import */ var _claude_translator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./claude-translator */ \"(app-pages-browser)/./src/lib/ai/claude-translator.ts\");\n/* harmony import */ var _yaml_processor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../yaml-processor */ \"(app-pages-browser)/./src/lib/yaml-processor.ts\");\n\n\n\nclass TranslationService {\n    // Initialize translator with configuration\n    initialize(config) {\n        this.config = config;\n        switch(config.provider){\n            case 'openai':\n                this.translator = new _openai_translator__WEBPACK_IMPORTED_MODULE_0__.OpenAITranslator(config.apiKey, config.model, config.baseUrl);\n                break;\n            case 'claude':\n                this.translator = new _claude_translator__WEBPACK_IMPORTED_MODULE_1__.ClaudeTranslator(config.apiKey, config.model);\n                break;\n            case 'gemini':\n                // TODO: Implement Gemini translator\n                throw new Error('Gemini translator not implemented yet');\n            default:\n                throw new Error(\"Unsupported AI provider: \".concat(config.provider));\n        }\n    }\n    // Translate a single text\n    async translateText(text) {\n        if (!this.translator || !this.config) {\n            throw new Error('Translation service not initialized');\n        }\n        return this.translator.translateText(text, {\n            targetLanguage: this.config.targetLanguage,\n            sourceLanguage: this.config.sourceLanguage,\n            context: this.config.context,\n            customDictionary: this.config.customDictionary\n        });\n    }\n    // Translate YAML structure with progress tracking\n    async translateYAMLStructure(originalData, structure, onProgress, signal) {\n        if (!this.translator || !this.config) {\n            throw new Error('Translation service not initialized');\n        }\n        // Filter translatable items\n        const translatableItems = structure.filter((item)=>item.isTranslatable).map((item)=>({\n                key: item.path,\n                value: item.value\n            }));\n        if (translatableItems.length === 0) {\n            return {\n                success: true,\n                translatedContent: _yaml_processor__WEBPACK_IMPORTED_MODULE_2__.YAMLProcessor.stringify(originalData),\n                totalTranslated: 0,\n                errors: [],\n                usage: {\n                    totalTokens: 0,\n                    totalCost: 0\n                }\n            };\n        }\n        const result = await this.translator.translateBatch(translatableItems, {\n            targetLanguage: this.config.targetLanguage,\n            sourceLanguage: this.config.sourceLanguage,\n            context: this.config.context,\n            customDictionary: this.config.customDictionary\n        }, onProgress, signal);\n        // If successful, reconstruct the YAML with translations\n        if (result.success) {\n            try {\n                let translatedData = JSON.parse(JSON.stringify(originalData));\n                // Apply translations to the data structure\n                const originalTranslatableItems = structure.filter((item)=>item.isTranslatable);\n                originalTranslatableItems.forEach((item, index)=>{\n                    const translatedValue = this.extractTranslationFromResult(result.translatedContent, item.path, item.value);\n                    if (translatedValue !== item.value) {\n                        translatedData = _yaml_processor__WEBPACK_IMPORTED_MODULE_2__.YAMLProcessor.updateValue(translatedData, item.path, translatedValue);\n                    }\n                });\n                result.translatedContent = _yaml_processor__WEBPACK_IMPORTED_MODULE_2__.YAMLProcessor.stringify(translatedData);\n            } catch (error) {\n                console.error('Failed to reconstruct YAML:', error);\n            // Fallback to simple format\n            }\n        }\n        return result;\n    }\n    // Extract translated value from result (helper method)\n    extractTranslationFromResult(content, key, originalValue) {\n        // Simple extraction - in a real implementation, this would be more sophisticated\n        const lines = content.split('\\n');\n        for (const line of lines){\n            if (line.includes(key)) {\n                const match = line.match(/:\\s*\"([^\"]*)\"/);\n                if (match) {\n                    return match[1];\n                }\n            }\n        }\n        return originalValue;\n    }\n    // Get translation estimate\n    getTranslationEstimate(structure) {\n        var _this_config, _this_config1;\n        const translatableCount = _yaml_processor__WEBPACK_IMPORTED_MODULE_2__.YAMLProcessor.getTranslatableCount(structure);\n        const estimatedTime = _yaml_processor__WEBPACK_IMPORTED_MODULE_2__.YAMLProcessor.estimateTranslationTime(structure);\n        // Rough cost estimate based on average tokens per item\n        const avgTokensPerItem = 50;\n        const totalTokens = translatableCount * avgTokensPerItem;\n        let costPer1KTokens = 0.002 // Default for GPT-3.5\n        ;\n        if (((_this_config = this.config) === null || _this_config === void 0 ? void 0 : _this_config.provider) === 'openai' && this.config.model.includes('gpt-4')) {\n            costPer1KTokens = 0.03;\n        } else if (((_this_config1 = this.config) === null || _this_config1 === void 0 ? void 0 : _this_config1.provider) === 'claude') {\n            costPer1KTokens = 0.009; // Average Claude pricing\n        }\n        const estimatedCost = totalTokens / 1000 * costPer1KTokens;\n        return {\n            itemCount: translatableCount,\n            estimatedTime,\n            estimatedCost\n        };\n    }\n    // Validate API key for a specific provider\n    static async validateApiKey(provider, apiKey, baseUrl) {\n        switch(provider){\n            case 'openai':\n                return _openai_translator__WEBPACK_IMPORTED_MODULE_0__.OpenAITranslator.validateApiKey(apiKey, baseUrl);\n            case 'claude':\n                return _claude_translator__WEBPACK_IMPORTED_MODULE_1__.ClaudeTranslator.validateApiKey(apiKey);\n            case 'gemini':\n                // TODO: Implement Gemini validation\n                return false;\n            default:\n                return false;\n        }\n    }\n    // Get available models for a provider\n    static async getAvailableModels(provider, apiKey, baseUrl) {\n        switch(provider){\n            case 'openai':\n                return apiKey ? _openai_translator__WEBPACK_IMPORTED_MODULE_0__.OpenAITranslator.getAvailableModels(apiKey, baseUrl) : [\n                    'gpt-4',\n                    'gpt-3.5-turbo'\n                ];\n            case 'claude':\n                return _claude_translator__WEBPACK_IMPORTED_MODULE_1__.ClaudeTranslator.getAvailableModels();\n            case 'gemini':\n                // TODO: Implement Gemini models\n                return [\n                    'gemini-pro'\n                ];\n            default:\n                return [];\n        }\n    }\n    // Get current configuration\n    getConfig() {\n        return this.config;\n    }\n    // Check if service is initialized\n    isInitialized() {\n        return this.translator !== null && this.config !== null;\n    }\n    // Reset service\n    reset() {\n        this.translator = null;\n        this.config = null;\n    }\n    constructor(){\n        this.translator = null;\n        this.config = null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWkvdHJhbnNsYXRpb24tc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNEO0FBQ0E7QUFRYztBQWtCN0QsTUFBTUc7SUFNWCwyQ0FBMkM7SUFDM0NDLFdBQVdDLE1BQWdDLEVBQVE7UUFDakQsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBRWQsT0FBUUEsT0FBT0MsUUFBUTtZQUNyQixLQUFLO2dCQUNILElBQUksQ0FBQ0MsVUFBVSxHQUFHLElBQUlQLGdFQUFnQkEsQ0FBQ0ssT0FBT0csTUFBTSxFQUFFSCxPQUFPSSxLQUFLLEVBQUVKLE9BQU9LLE9BQU87Z0JBQ2xGO1lBQ0YsS0FBSztnQkFDSCxJQUFJLENBQUNILFVBQVUsR0FBRyxJQUFJTixnRUFBZ0JBLENBQUNJLE9BQU9HLE1BQU0sRUFBRUgsT0FBT0ksS0FBSztnQkFDbEU7WUFDRixLQUFLO2dCQUNILG9DQUFvQztnQkFDcEMsTUFBTSxJQUFJRSxNQUFNO1lBQ2xCO2dCQUNFLE1BQU0sSUFBSUEsTUFBTSw0QkFBNEMsT0FBaEJOLE9BQU9DLFFBQVE7UUFDL0Q7SUFDRjtJQUVBLDBCQUEwQjtJQUMxQixNQUFNTSxjQUFjQyxJQUFZLEVBQThCO1FBQzVELElBQUksQ0FBQyxJQUFJLENBQUNOLFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQ0YsTUFBTSxFQUFFO1lBQ3BDLE1BQU0sSUFBSU0sTUFBTTtRQUNsQjtRQUVBLE9BQU8sSUFBSSxDQUFDSixVQUFVLENBQUNLLGFBQWEsQ0FBQ0MsTUFBTTtZQUN6Q0MsZ0JBQWdCLElBQUksQ0FBQ1QsTUFBTSxDQUFDUyxjQUFjO1lBQzFDQyxnQkFBZ0IsSUFBSSxDQUFDVixNQUFNLENBQUNVLGNBQWM7WUFDMUNDLFNBQVMsSUFBSSxDQUFDWCxNQUFNLENBQUNXLE9BQU87WUFDNUJDLGtCQUFrQixJQUFJLENBQUNaLE1BQU0sQ0FBQ1ksZ0JBQWdCO1FBQ2hEO0lBQ0Y7SUFFQSxrREFBa0Q7SUFDbEQsTUFB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QyxPQUFPLElBQUksQ0FBQ2xFLE1BQU07SUFDcEI7SUFFQSxrQ0FBa0M7SUFDbENtRSxnQkFBeUI7UUFDdkIsT0FBTyxJQUFJLENBQUNqRSxVQUFVLEtBQUssUUFBUSxJQUFJLENBQUNGLE1BQU0sS0FBSztJQUNyRDtJQUVBLGdCQUFnQjtJQUNoQm9FLFFBQWM7UUFDWixJQUFJLENBQUNsRSxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDRixNQUFNLEdBQUc7SUFDaEI7SUEvTEEsYUFBYzthQUhORSxhQUFvQzthQUNwQ0YsU0FBMEM7SUFFbkM7QUFnTWpCIiwic291cmNlcyI6WyIvVXNlcnMvc2h1YWkvZ2l0aHViL3RyYW5zLXlhbWwvc3JjL2xpYi9haS90cmFuc2xhdGlvbi1zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9wZW5BSVRyYW5zbGF0b3IgfSBmcm9tICcuL29wZW5haS10cmFuc2xhdG9yJ1xuaW1wb3J0IHsgQ2xhdWRlVHJhbnNsYXRvciB9IGZyb20gJy4vY2xhdWRlLXRyYW5zbGF0b3InXG5pbXBvcnQgeyBcbiAgQmFzZVRyYW5zbGF0b3IsIFxuICBUcmFuc2xhdGlvbk9wdGlvbnMsIFxuICBUcmFuc2xhdGlvblJlc3VsdCwgXG4gIFRyYW5zbGF0aW9uUHJvZ3Jlc3MsXG4gIFN0cmVhbWluZ1RyYW5zbGF0aW9uUmVzdWx0IFxufSBmcm9tICcuL2Jhc2UtdHJhbnNsYXRvcidcbmltcG9ydCB7IFlBTUxQcm9jZXNzb3IsIFlBTUxTdHJ1Y3R1cmVJdGVtIH0gZnJvbSAnLi4veWFtbC1wcm9jZXNzb3InXG5cbmV4cG9ydCB0eXBlIEFJUHJvdmlkZXIgPSAnb3BlbmFpJyB8ICdjbGF1ZGUnIHwgJ2dlbWluaSdcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xhdGlvbkNvbmZpZyB7XG4gIHByb3ZpZGVyOiBBSVByb3ZpZGVyXG4gIG1vZGVsOiBzdHJpbmdcbiAgYXBpS2V5OiBzdHJpbmdcbiAgYmFzZVVybD86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0aW9uU2Vzc2lvbkNvbmZpZyBleHRlbmRzIFRyYW5zbGF0aW9uQ29uZmlnIHtcbiAgdGFyZ2V0TGFuZ3VhZ2U6IHN0cmluZ1xuICBzb3VyY2VMYW5ndWFnZT86IHN0cmluZ1xuICBjb250ZXh0Pzogc3RyaW5nXG4gIGN1c3RvbURpY3Rpb25hcnk/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG59XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2xhdGlvblNlcnZpY2Uge1xuICBwcml2YXRlIHRyYW5zbGF0b3I6IEJhc2VUcmFuc2xhdG9yIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBjb25maWc6IFRyYW5zbGF0aW9uU2Vzc2lvbkNvbmZpZyB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8vIEluaXRpYWxpemUgdHJhbnNsYXRvciB3aXRoIGNvbmZpZ3VyYXRpb25cbiAgaW5pdGlhbGl6ZShjb25maWc6IFRyYW5zbGF0aW9uU2Vzc2lvbkNvbmZpZyk6IHZvaWQge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnXG4gICAgXG4gICAgc3dpdGNoIChjb25maWcucHJvdmlkZXIpIHtcbiAgICAgIGNhc2UgJ29wZW5haSc6XG4gICAgICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBPcGVuQUlUcmFuc2xhdG9yKGNvbmZpZy5hcGlLZXksIGNvbmZpZy5tb2RlbCwgY29uZmlnLmJhc2VVcmwpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdjbGF1ZGUnOlxuICAgICAgICB0aGlzLnRyYW5zbGF0b3IgPSBuZXcgQ2xhdWRlVHJhbnNsYXRvcihjb25maWcuYXBpS2V5LCBjb25maWcubW9kZWwpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdnZW1pbmknOlxuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgR2VtaW5pIHRyYW5zbGF0b3JcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZW1pbmkgdHJhbnNsYXRvciBub3QgaW1wbGVtZW50ZWQgeWV0JylcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgQUkgcHJvdmlkZXI6ICR7Y29uZmlnLnByb3ZpZGVyfWApXG4gICAgfVxuICB9XG5cbiAgLy8gVHJhbnNsYXRlIGEgc2luZ2xlIHRleHRcbiAgYXN5bmMgdHJhbnNsYXRlVGV4dCh0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPFRyYW5zbGF0aW9uUmVzdWx0PiB7XG4gICAgaWYgKCF0aGlzLnRyYW5zbGF0b3IgfHwgIXRoaXMuY29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zbGF0aW9uIHNlcnZpY2Ugbm90IGluaXRpYWxpemVkJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZVRleHQodGV4dCwge1xuICAgICAgdGFyZ2V0TGFuZ3VhZ2U6IHRoaXMuY29uZmlnLnRhcmdldExhbmd1YWdlLFxuICAgICAgc291cmNlTGFuZ3VhZ2U6IHRoaXMuY29uZmlnLnNvdXJjZUxhbmd1YWdlLFxuICAgICAgY29udGV4dDogdGhpcy5jb25maWcuY29udGV4dCxcbiAgICAgIGN1c3RvbURpY3Rpb25hcnk6IHRoaXMuY29uZmlnLmN1c3RvbURpY3Rpb25hcnlcbiAgICB9KVxuICB9XG5cbiAgLy8gVHJhbnNsYXRlIFlBTUwgc3RydWN0dXJlIHdpdGggcHJvZ3Jlc3MgdHJhY2tpbmdcbiAgYXN5bmMgdHJhbnNsYXRlWUFNTFN0cnVjdHVyZShcbiAgICBvcmlnaW5hbERhdGE6IGFueSxcbiAgICBzdHJ1Y3R1cmU6IFlBTUxTdHJ1Y3R1cmVJdGVtW10sXG4gICAgb25Qcm9ncmVzcz86IChwcm9ncmVzczogVHJhbnNsYXRpb25Qcm9ncmVzcykgPT4gdm9pZCxcbiAgICBzaWduYWw/OiBBYm9ydFNpZ25hbFxuICApOiBQcm9taXNlPFN0cmVhbWluZ1RyYW5zbGF0aW9uUmVzdWx0PiB7XG4gICAgaWYgKCF0aGlzLnRyYW5zbGF0b3IgfHwgIXRoaXMuY29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zbGF0aW9uIHNlcnZpY2Ugbm90IGluaXRpYWxpemVkJylcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgdHJhbnNsYXRhYmxlIGl0ZW1zXG4gICAgY29uc3QgdHJhbnNsYXRhYmxlSXRlbXMgPSBzdHJ1Y3R1cmVcbiAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmlzVHJhbnNsYXRhYmxlKVxuICAgICAgLm1hcChpdGVtID0+ICh7XG4gICAgICAgIGtleTogaXRlbS5wYXRoLFxuICAgICAgICB2YWx1ZTogaXRlbS52YWx1ZVxuICAgICAgfSkpXG5cbiAgICBpZiAodHJhbnNsYXRhYmxlSXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB0cmFuc2xhdGVkQ29udGVudDogWUFNTFByb2Nlc3Nvci5zdHJpbmdpZnkob3JpZ2luYWxEYXRhKSxcbiAgICAgICAgdG90YWxUcmFuc2xhdGVkOiAwLFxuICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICB1c2FnZToge1xuICAgICAgICAgIHRvdGFsVG9rZW5zOiAwLFxuICAgICAgICAgIHRvdGFsQ29zdDogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZUJhdGNoKFxuICAgICAgdHJhbnNsYXRhYmxlSXRlbXMsXG4gICAgICB7XG4gICAgICAgIHRhcmdldExhbmd1YWdlOiB0aGlzLmNvbmZpZy50YXJnZXRMYW5ndWFnZSxcbiAgICAgICAgc291cmNlTGFuZ3VhZ2U6IHRoaXMuY29uZmlnLnNvdXJjZUxhbmd1YWdlLFxuICAgICAgICBjb250ZXh0OiB0aGlzLmNvbmZpZy5jb250ZXh0LFxuICAgICAgICBjdXN0b21EaWN0aW9uYXJ5OiB0aGlzLmNvbmZpZy5jdXN0b21EaWN0aW9uYXJ5XG4gICAgICB9LFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIHNpZ25hbFxuICAgIClcblxuICAgIC8vIElmIHN1Y2Nlc3NmdWwsIHJlY29uc3RydWN0IHRoZSBZQU1MIHdpdGggdHJhbnNsYXRpb25zXG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgdHJhbnNsYXRlZERhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9yaWdpbmFsRGF0YSkpXG4gICAgICAgIFxuICAgICAgICAvLyBBcHBseSB0cmFuc2xhdGlvbnMgdG8gdGhlIGRhdGEgc3RydWN0dXJlXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVHJhbnNsYXRhYmxlSXRlbXMgPSBzdHJ1Y3R1cmUuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pc1RyYW5zbGF0YWJsZSlcbiAgICAgICAgb3JpZ2luYWxUcmFuc2xhdGFibGVJdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZWRWYWx1ZSA9IHRoaXMuZXh0cmFjdFRyYW5zbGF0aW9uRnJvbVJlc3VsdChyZXN1bHQudHJhbnNsYXRlZENvbnRlbnQsIGl0ZW0ucGF0aCwgaXRlbS52YWx1ZSlcbiAgICAgICAgICBpZiAodHJhbnNsYXRlZFZhbHVlICE9PSBpdGVtLnZhbHVlKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGVkRGF0YSA9IFlBTUxQcm9jZXNzb3IudXBkYXRlVmFsdWUodHJhbnNsYXRlZERhdGEsIGl0ZW0ucGF0aCwgdHJhbnNsYXRlZFZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXN1bHQudHJhbnNsYXRlZENvbnRlbnQgPSBZQU1MUHJvY2Vzc29yLnN0cmluZ2lmeSh0cmFuc2xhdGVkRGF0YSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZWNvbnN0cnVjdCBZQU1MOicsIGVycm9yKVxuICAgICAgICAvLyBGYWxsYmFjayB0byBzaW1wbGUgZm9ybWF0XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gRXh0cmFjdCB0cmFuc2xhdGVkIHZhbHVlIGZyb20gcmVzdWx0IChoZWxwZXIgbWV0aG9kKVxuICBwcml2YXRlIGV4dHJhY3RUcmFuc2xhdGlvbkZyb21SZXN1bHQoY29udGVudDogc3RyaW5nLCBrZXk6IHN0cmluZywgb3JpZ2luYWxWYWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBTaW1wbGUgZXh0cmFjdGlvbiAtIGluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCBiZSBtb3JlIHNvcGhpc3RpY2F0ZWRcbiAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBpZiAobGluZS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaCgvOlxccypcIihbXlwiXSopXCIvKVxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hbMV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZVxuICB9XG5cbiAgLy8gR2V0IHRyYW5zbGF0aW9uIGVzdGltYXRlXG4gIGdldFRyYW5zbGF0aW9uRXN0aW1hdGUoc3RydWN0dXJlOiBZQU1MU3RydWN0dXJlSXRlbVtdKToge1xuICAgIGl0ZW1Db3VudDogbnVtYmVyXG4gICAgZXN0aW1hdGVkVGltZTogbnVtYmVyXG4gICAgZXN0aW1hdGVkQ29zdDogbnVtYmVyXG4gIH0ge1xuICAgIGNvbnN0IHRyYW5zbGF0YWJsZUNvdW50ID0gWUFNTFByb2Nlc3Nvci5nZXRUcmFuc2xhdGFibGVDb3VudChzdHJ1Y3R1cmUpXG4gICAgY29uc3QgZXN0aW1hdGVkVGltZSA9IFlBTUxQcm9jZXNzb3IuZXN0aW1hdGVUcmFuc2xhdGlvblRpbWUoc3RydWN0dXJlKVxuICAgIFxuICAgIC8vIFJvdWdoIGNvc3QgZXN0aW1hdGUgYmFzZWQgb24gYXZlcmFnZSB0b2tlbnMgcGVyIGl0ZW1cbiAgICBjb25zdCBhdmdUb2tlbnNQZXJJdGVtID0gNTBcbiAgICBjb25zdCB0b3RhbFRva2VucyA9IHRyYW5zbGF0YWJsZUNvdW50ICogYXZnVG9rZW5zUGVySXRlbVxuICAgIGxldCBjb3N0UGVyMUtUb2tlbnMgPSAwLjAwMiAvLyBEZWZhdWx0IGZvciBHUFQtMy41XG5cbiAgICBpZiAodGhpcy5jb25maWc/LnByb3ZpZGVyID09PSAnb3BlbmFpJyAmJiB0aGlzLmNvbmZpZy5tb2RlbC5pbmNsdWRlcygnZ3B0LTQnKSkge1xuICAgICAgY29zdFBlcjFLVG9rZW5zID0gMC4wM1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb25maWc/LnByb3ZpZGVyID09PSAnY2xhdWRlJykge1xuICAgICAgY29zdFBlcjFLVG9rZW5zID0gMC4wMDkgLy8gQXZlcmFnZSBDbGF1ZGUgcHJpY2luZ1xuICAgIH1cblxuICAgIGNvbnN0IGVzdGltYXRlZENvc3QgPSAodG90YWxUb2tlbnMgLyAxMDAwKSAqIGNvc3RQZXIxS1Rva2Vuc1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1Db3VudDogdHJhbnNsYXRhYmxlQ291bnQsXG4gICAgICBlc3RpbWF0ZWRUaW1lLFxuICAgICAgZXN0aW1hdGVkQ29zdFxuICAgIH1cbiAgfVxuXG4gIC8vIFZhbGlkYXRlIEFQSSBrZXkgZm9yIGEgc3BlY2lmaWMgcHJvdmlkZXJcbiAgc3RhdGljIGFzeW5jIHZhbGlkYXRlQXBpS2V5KHByb3ZpZGVyOiBBSVByb3ZpZGVyLCBhcGlLZXk6IHN0cmluZywgYmFzZVVybD86IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHN3aXRjaCAocHJvdmlkZXIpIHtcbiAgICAgIGNhc2UgJ29wZW5haSc6XG4gICAgICAgIHJldHVybiBPcGVuQUlUcmFuc2xhdG9yLnZhbGlkYXRlQXBpS2V5KGFwaUtleSwgYmFzZVVybClcbiAgICAgIGNhc2UgJ2NsYXVkZSc6XG4gICAgICAgIHJldHVybiBDbGF1ZGVUcmFuc2xhdG9yLnZhbGlkYXRlQXBpS2V5KGFwaUtleSlcbiAgICAgIGNhc2UgJ2dlbWluaSc6XG4gICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBHZW1pbmkgdmFsaWRhdGlvblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBhdmFpbGFibGUgbW9kZWxzIGZvciBhIHByb3ZpZGVyXG4gIHN0YXRpYyBhc3luYyBnZXRBdmFpbGFibGVNb2RlbHMocHJvdmlkZXI6IEFJUHJvdmlkZXIsIGFwaUtleT86IHN0cmluZywgYmFzZVVybD86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBzd2l0Y2ggKHByb3ZpZGVyKSB7XG4gICAgICBjYXNlICdvcGVuYWknOlxuICAgICAgICByZXR1cm4gYXBpS2V5ID8gT3BlbkFJVHJhbnNsYXRvci5nZXRBdmFpbGFibGVNb2RlbHMoYXBpS2V5LCBiYXNlVXJsKSA6IFsnZ3B0LTQnLCAnZ3B0LTMuNS10dXJibyddXG4gICAgICBjYXNlICdjbGF1ZGUnOlxuICAgICAgICByZXR1cm4gQ2xhdWRlVHJhbnNsYXRvci5nZXRBdmFpbGFibGVNb2RlbHMoKVxuICAgICAgY2FzZSAnZ2VtaW5pJzpcbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IEdlbWluaSBtb2RlbHNcbiAgICAgICAgcmV0dXJuIFsnZ2VtaW5pLXBybyddXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cblxuICAvLyBHZXQgY3VycmVudCBjb25maWd1cmF0aW9uXG4gIGdldENvbmZpZygpOiBUcmFuc2xhdGlvblNlc3Npb25Db25maWcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWdcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHNlcnZpY2UgaXMgaW5pdGlhbGl6ZWRcbiAgaXNJbml0aWFsaXplZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdG9yICE9PSBudWxsICYmIHRoaXMuY29uZmlnICE9PSBudWxsXG4gIH1cblxuICAvLyBSZXNldCBzZXJ2aWNlXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG51bGxcbiAgICB0aGlzLmNvbmZpZyA9IG51bGxcbiAgfVxufSJdLCJuYW1lcyI6WyJPcGVuQUlUcmFuc2xhdG9yIiwiQ2xhdWRlVHJhbnNsYXRvciIsIllBTUxQcm9jZXNzb3IiLCJUcmFuc2xhdGlvblNlcnZpY2UiLCJpbml0aWFsaXplIiwiY29uZmlnIiwicHJvdmlkZXIiLCJ0cmFuc2xhdG9yIiwiYXBpS2V5IiwibW9kZWwiLCJiYXNlVXJsIiwiRXJyb3IiLCJ0cmFuc2xhdGVUZXh0IiwidGV4dCIsInRhcmdldExhbmd1YWdlIiwic291cmNlTGFuZ3VhZ2UiLCJjb250ZXh0IiwiY3VzdG9tRGljdGlvbmFyeSIsInRyYW5zbGF0ZVlBTUxTdHJ1Y3R1cmUiLCJvcmlnaW5hbERhdGEiLCJzdHJ1Y3R1cmUiLCJvblByb2dyZXNzIiwic2lnbmFsIiwidHJhbnNsYXRhYmxlSXRlbXMiLCJmaWx0ZXIiLCJpdGVtIiwiaXNUcmFuc2xhdGFibGUiLCJtYXAiLCJrZXkiLCJwYXRoIiwidmFsdWUiLCJsZW5ndGgiLCJzdWNjZXNzIiwidHJhbnNsYXRlZENvbnRlbnQiLCJzdHJpbmdpZnkiLCJ0b3RhbFRyYW5zbGF0ZWQiLCJlcnJvcnMiLCJ1c2FnZSIsInRvdGFsVG9rZW5zIiwidG90YWxDb3N0IiwicmVzdWx0IiwidHJhbnNsYXRlQmF0Y2giLCJ0cmFuc2xhdGVkRGF0YSIsIkpTT04iLCJwYXJzZSIsIm9yaWdpbmFsVHJhbnNsYXRhYmxlSXRlbXMiLCJmb3JFYWNoIiwiaW5kZXgiLCJ0cmFuc2xhdGVkVmFsdWUiLCJleHRyYWN0VHJhbnNsYXRpb25Gcm9tUmVzdWx0IiwidXBkYXRlVmFsdWUiLCJlcnJvciIsImNvbnNvbGUiLCJjb250ZW50Iiwib3JpZ2luYWxWYWx1ZSIsImxpbmVzIiwic3BsaXQiLCJsaW5lIiwiaW5jbHVkZXMiLCJtYXRjaCIsImdldFRyYW5zbGF0aW9uRXN0aW1hdGUiLCJ0cmFuc2xhdGFibGVDb3VudCIsImdldFRyYW5zbGF0YWJsZUNvdW50IiwiZXN0aW1hdGVkVGltZSIsImVzdGltYXRlVHJhbnNsYXRpb25UaW1lIiwiYXZnVG9rZW5zUGVySXRlbSIsImNvc3RQZXIxS1Rva2VucyIsImVzdGltYXRlZENvc3QiLCJpdGVtQ291bnQiLCJ2YWxpZGF0ZUFwaUtleSIsImdldEF2YWlsYWJsZU1vZGVscyIsImdldENvbmZpZyIsImlzSW5pdGlhbGl6ZWQiLCJyZXNldCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/ai/translation-service.ts\n"));

/***/ })

});